(function(e){function t(t){for(var a,r,s=t[0],l=t[1],c=t[2],d=0,h=[];d<s.length;d++)r=s[d],Object.prototype.hasOwnProperty.call(i,r)&&i[r]&&h.push(i[r][0]),i[r]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a]);u&&u(t);while(h.length)h.shift()();return o.push.apply(o,c||[]),n()}function n(){for(var e,t=0;t<o.length;t++){for(var n=o[t],a=!0,s=1;s<n.length;s++){var l=n[s];0!==i[l]&&(a=!1)}a&&(o.splice(t--,1),e=r(r.s=n[0]))}return e}var a={},i={app:0},o=[];function r(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=e,r.c=a,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/plasmafractal-gl/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],l=s.push.bind(s);s.push=t,s=s.slice();for(var c=0;c<s.length;c++)t(s[c]);var u=l;o.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("56d7")},"0388":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",[n("b-form-checkbox",{staticClass:"z42opt-check",attrs:{id:e.id,checked:e.value,disabled:e.disabled},on:{change:function(t){return e.$emit("input",t)}}},[e._v(" "+e._s(e.optDesc.$attrs.title)+" ")])],1)},i=[],o=n("ca11"),r={name:"z42opt-check",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created(){}},s=r,l=n("2877"),c=Object(l["a"])(s,a,i,!1,null,null,null);t["default"]=c.exports},"094b":function(e,t,n){"use strict";n.d(t,"f",(function(){return o})),n.d(t,"e",(function(){return r})),n.d(t,"c",(function(){return s})),n.d(t,"a",(function(){return l})),n.d(t,"d",(function(){return c})),n.d(t,"b",(function(){return u}));n("e260"),n("b680"),n("25f0"),n("ddb0");var a=n("ca11"),i=n("66cb");n.d(t,"g",(function(){return a["a"]}));class o extends a["b"]{constructor(e){super(e)}$serialize(e){return Math.trunc(e).toString()}$deserialize(e){return e=parseInt(e,10),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):d(Math.ceil(e),this.$attrs.min,this.$attrs.max)}$displayValue(e){null!=this.$attrs.displayFactor&&(e*=this.$attrs.displayFactor);var t=Math.trunc(e).toString();return null!=this.$attrs.displayUnit&&(t+=" "+this.$attrs.displayUnit),t}get $defaultComponent(){return"z42opt-range"}}class r extends a["b"]{constructor(e){super(e)}$serialize(e){return h(e,this.$attrs.maxDecimals)}$deserialize(e){return e=parseFloat(e),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):d(e,this.$attrs.min,this.$attrs.max)}$displayValue(e){null!=this.$attrs.displayFactor&&(e*=this.$attrs.displayFactor),null!=this.$attrs.maxDecimals&&(e=Number(e.toFixed(this.$attrs.maxDecimals)));var t=e.toString();return null!=this.$attrs.displayUnit&&(t+=" "+this.$attrs.displayUnit),t}get $defaultComponent(){return"z42opt-range"}}class s extends r{constructor(e){super(e)}$serialize(e){var t=h(e,this.$attrs.maxDecimals);return t.indexOf(".")<0&&0!==e&&(t+="."),t}$deserialize(e){var t=e.indexOf(".")>=0;return e=parseFloat(e),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):(t||(e/=1e3),d(e,this.$attrs.min,this.$attrs.max))}get $defaultComponent(){return"z42opt-range"}}class l extends a["b"]{constructor(e){super(e)}$serialize(e){return e?"1":"0"}$deserialize(e){var t=e.toString().toLowerCase();return"true"===t||"1"===t}get $defaultComponent(){return"z42opt-check"}}class c extends a["b"]{constructor(e){super(e)}$serialize(e){for(var[t,n]of(e=String(e).toLowerCase(),Object.entries(this.$attrs.values))){if(n.shortKey.toLowerCase()===e)return n.shortKey;if(t.toLowerCase()===e)return n.shortKey}return null}$deserialize(e){for(var[t,n]of(e=String(e).toLowerCase(),Object.entries(this.$attrs.values))){if(n.shortKey.toLowerCase()===e)return t;if(t.toLowerCase()===e)return t}return this.$parseError(e),this.$attrs.defaultVal}get $defaultComponent(){return"z42opt-select"}}class u extends a["b"]{constructor(e){super(e)}$serialize(e){return i(e).toHex()}$deserialize(e){var t=i(e);return t.isValid()?t.toRgb():(this.$parseError(e),this.$attrs.defaultVal)}get $defaultComponent(){return"z42opt-color"}}function d(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return t&&e<t?t:n&&e>n?n:e}function h(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return null!=t&&(e=Number(e.toFixed(t))),e=e.toString(),"0"==e.charAt(0)&&"."==e.charAt(1)?e.substring(1):"-"==e.charAt(0)&&"0"==e.charAt(1)&&"."==e.charAt(2)?"-"+e.substring(2):e}},"0954":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.label,"label-for":e.labelFor,disabled:e.disabled}},[n("canvas",{staticClass:"z42opt-palette-easefun-canvas",attrs:{id:e.easeFunCanvasId}}),n("canvas",{staticClass:"z42opt-palette-gradient-canvas",attrs:{id:e.gradientCanvasId}}),n("div",{staticClass:"z42opt-palette-slider",attrs:{id:e.id,disabled:e.disabled}}),null!==e.selectedHandleIndex?n("z42opt-container",{key:e.selectedPaletteItemId,staticClass:"container px-0",attrs:{id:e.selectedPaletteItemId,optData:e.selectedPaletteItem,optDesc:e.optDesc.segment,optView:e.selectedPaletteItemView},on:{"opt-modified":function(t){return e.onPaletteAttributeInput(t)}}}):e._e(),null===e.selectedHandleIndex?n("div",{staticClass:"text-info"},[n("p",[e._v(" Click handle to "),n("b",[e._v("edit")]),e._v(" properties."),n("br"),e._v(" Curve displays luminance. Change ease functions to modify curve shape. ")]),n("p",[e._v(" Double-click to "),n("b",[e._v("add")]),e._v(" handle."),n("br"),e._v(" Drag up/down or shift+click to "),n("b",[e._v("remove")]),e._v(" handle. ")])]):e._e()],1)},i=[],o=(n("e260"),n("4e82"),n("c19f"),n("ace4"),n("fb2c"),n("b39a"),n("ddb0"),n("2216")),r=n("4752"),s=n("be4d"),l=n("e9fa"),c=n.n(l),u=n("6dd8"),d=new WeakMap,h=50,p="z42opt-palette-handle-to-remove",f="z42opt-palette-handle-selected",m={name:"z42opt-palette",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{type:Array,required:!0},optDesc:{type:o["a"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},data(){return{selectedHandleIndex:null,selectedPaletteItem:null,selectedPaletteItemView:{options:[""]}}},mounted(){var e=v(this.value,this.optDesc),t=new u["a"](this.onCanvasResize);d.set(this,{palette:e,currentMousePos:null,slideStartMousePos:null,slidingHandleElement:null,resizeObserver:t});var n={start:w(e),range:{min:0,max:1},step:.001,behaviour:"unconstrained"};null!=this.optDesc.$attrs.step&&(n.step=this.optDesc.$attrs.step),this.recreateSlider(n),this.updateCanvas(),t.observe(document.getElementById(this.gradientCanvasId)),t.observe(document.getElementById(this.easeFunCanvasId)),_.isEqual(e,this.value)||this.emitPaletteInputEvent()},beforeDestroy(){var e=d.get(this);window.removeEventListener("mousemove",this.onSlideMouseMove),window.removeEventListener("touchmove",this.onSlideTouchMove),e.resizeObserver.disconnect()},computed:{easeFunCanvasId(){return this.id+"#easeFunCanvas"},gradientCanvasId(){return this.id+"#gradientCanvas"},selectedPaletteItemId(){return this.id+"#segmentOptions"},label(){return this.optDesc.$attrs.title?this.optDesc.$attrs.title+":":void 0},labelFor(){return this.optDesc.$attrs.title?this.id:void 0}},methods:{getSliderElement(){return document.getElementById(this.id)},getSliderWidth(){return getSliderElement().offsetWidth},getEaseFunCanvasHeight(){return document.getElementById(this.easeFunCanvasId).offsetHeight},recreateSlider(e){var t=this,n=this.getSliderElement();for(var a of(n.noUiSlider&&n.noUiSlider.destroy(),c.a.create(n,e),n.noUiSlider.on("start",(function(){return t.onSlideStart(...arguments)})),n.noUiSlider.on("slide",(function(){return t.onSlide(...arguments)})),n.noUiSlider.on("end",(function(){return t.onSlideEnd(...arguments)})),n.getElementsByClassName("noUi-connects")))a.addEventListener("dblclick",this.onConnectsDblClick);for(var i of n.getElementsByClassName("noUi-handle"))i.addEventListener("click",this.onHandleClick),i.addEventListener("focus",this.onHandleFocus)},onSlide(e,t,n,a,i){var o=d.get(this).palette,r=w(o);if(!_.isEqual(r,n)){for(var s in n)o[s].pos=n[s];this.updateCanvas(),this.emitPaletteInputEvent()}},onConnectsDblClick(e){var t=0;e.target.clientWidth>0&&(t=e.offsetX/e.target.clientWidth),t=_.clamp(t,0,1);var n=_.cloneDeep(d.get(this).palette),a={pos:t};r["e"](a,this.optDesc.segment),n.push(a),this.setPaletteFromOutside(n),this.setSelectedHandle(n.length-1),this.emitPaletteInputEvent()},onHandleClick(e){if(e.shiftKey){e.preventDefault();var t=this.handleIndexFromElement(e.target);t>=0&&this.removeHandleAtIndex(t)}},onSlideStart(e,t,n,a,i){var o=d.get(this);o.slideStartMousePos=null,o.slidingHandleElement=this.handleElements()[t],window.addEventListener("mousemove",this.onSlideMouseMove),window.addEventListener("touchmove",this.onSlideTouchMove)},onSlideMouseMove(e){this.onSlideMouseTouchMove({x:e.screenX,y:e.screenY})},onSlideTouchMove(e){e.changedTouches.length>0&&this.onSlideMouseTouchMove({x:e.changedTouches[0].screenX,y:e.changedTouches[0].screenY})},onSlideMouseTouchMove(e){var t=d.get(this);t.currentMousePos=_.clone(e),t.slideStartMousePos||(t.slideStartMousePos=_.clone(e));var n=Math.abs(e.y-t.slideStartMousePos.y);n>h&&t.palette.length>1?t.slidingHandleElement.classList.add(p):t.slidingHandleElement.classList.remove(p)},onSlideEnd(e,t,n,a,i){var o=d.get(this);if(o.slidingHandleElement.classList.remove(p),o.slideStartMousePos){var r=Math.abs(o.currentMousePos.y-o.slideStartMousePos.y);r>h&&this.removeHandleAtIndex(t)}window.removeEventListener("mousemove",this.onSlideMouseMove),window.removeEventListener("touchmove",this.onSlideTouchMove)},onHandleFocus(e){var t=this.handleIndexFromElement(e.target);if(t>=0){var n=this.handleElements(),a=n[t];if(a&&a.classList.add(f),null!=this.selectedHandleIndex){var i=n[this.selectedHandleIndex];i&&i.classList.remove(f)}this.selectedHandleIndex=t;var o=d.get(this).palette;this.selectedPaletteItem=_.cloneDeep(o[t])}},onPaletteAttributeInput(e){if(null!=this.selectedHandleIndex){var t=_.get(this.selectedPaletteItem,e.path);if(!_.isEqual(t,e.value)){_.set(this.selectedPaletteItem,e.path,_.cloneDeep(e.value));var n=d.get(this).palette;_.set(n[this.selectedHandleIndex],e.path,_.cloneDeep(e.value)),this.updateCanvas(),this.emitPaletteInputEvent()}}},onCanvasResize(e){for(var t of e){var n=t.contentRect,a=n.width*window.devicePixelRatio,i=n.height*window.devicePixelRatio;t.target.width===a&&t.target.height===i||(t.target.width=a,t.target.height=i,this.updateCanvas({isEaseFunCanvas:t.target.id==this.easeFunCanvasId,isGradientCanvas:t.target.id==this.gradientCanvasId}))}},handleElements(){return Array.from(this.getSliderElement().getElementsByClassName("noUi-handle"))},handleIndexFromElement(e){var t=this.handleElements();return t.findIndex(t=>t.contains(e))},setPaletteFromOutside(e){var t=d.get(this).palette,n=w(e),a=this.getSliderElement().noUiSlider;if(e.length!=t.length){var i=a.options;i.start=n,this.recreateSlider(i)}else a.set(n);d.get(this).palette=e,this.updateCanvas()},removeHandleAtIndex(e){var t=d.get(this).palette;if(t.length>1){var n=_.cloneDeep(t);n.splice(e,1),this.setPaletteFromOutside(n),this.setSelectedHandle((e+1)%n.length),this.emitPaletteInputEvent()}},setSelectedHandle(e){var t=this.handleElements();t[e].focus()},emitPaletteInputEvent(){var e=d.get(this).palette;this.$emit("input",_.cloneDeep(e))},updateCanvas(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{isEaseFunCanvas:!0,isGradientCanvas:!0},t=d.get(this).palette,n=this.optDesc.$resolvePaletteEaseFunctions(t);e.isEaseFunCanvas&&this.updateEaseFunCanvas(n),e.isGradientCanvas&&this.updateGradientCanvas(n)},updateEaseFunCanvas(e){var t=document.getElementById(this.easeFunCanvasId),n=t.width,a=t.height;if(0!==n&&0!==a){var i=t.getContext("2d");i.fillStyle="rgba( 0, 0, 0, 0.3 )",i.strokeStyle="rgb( 255, 255, 255 )",i.lineWidth=window.devicePixelRatio,i.clearRect(0,0,n,a),i.fillRect(0,0,n,a);var o=n+1,r=a-2*i.lineWidth,l=new Uint32Array(new ArrayBuffer(o*Uint32Array.BYTES_PER_ELEMENT));s["e"](l,l.length,e),b(i,0,i.lineWidth,o,r,l,y)}},updateGradientCanvas(e){var t=document.getElementById(this.gradientCanvasId),n=t.width,a=t.height;if(0!==n&&0!==a){var i=t.getContext("2d"),o=i.createImageData(n,1),r=new Uint32Array(o.data.buffer);s["e"](r,r.length,e);for(var l=0;l<a;++l)i.putImageData(o,0,l)}}},watch:{value:{deep:!0,handler:function(e,t){var n=v(e,this.optDesc),a=d.get(this).palette,i=g(n),o=g(a);_.isEqual(i,o)||this.setPaletteFromOutside(n)}}}};function v(e,t){var n={pos:0};if(r["e"](n,t.segment),!Array.isArray(e)||0===e.length){var a=_.cloneDeep(n);return a.pos=.5,a.color={r:255,g:255,b:255,a:1},[n,a]}for(var i=_.cloneDeep(e),o=0;o<i.length;++o)i[o]=i[o]||{},_.defaultsDeep(i[o],n);return i}function g(e){var t=_.cloneDeep(e);return t.sort((e,t)=>e.pos-t.pos),t}function w(e){return e.map(e=>e.pos)}function b(e,t,n,a,i,o,r){var s=Math.trunc(t);n=Math.trunc(n);var l=e=>n+i-r(o[e])*i;e.beginPath();var c=l(0);e.moveTo(s,c);for(var u=1;u<a;++u){var d=u,h=l(u);(h!=c||u>=a-1)&&(d-s>1&&e.lineTo(d-1,c),e.lineTo(d,h),s=d,c=h)}e.stroke()}function y(e){var t=e>>16&255,n=e>>8&255,a=255&e;return(.299*t+.587*n+.114*a)/255}var E=m,x=n("2877"),P=Object(x["a"])(E,a,i,!1,null,null,null);t["default"]=P.exports},"11f2":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._l(e.optView.options,(function(t){return[e._l(e.resolveOptDesc(t),(function(t){return[e.isAttrTrue(t.node,"depends")?n(t.node.$component,{key:e.childId(t.path),tag:"component",attrs:{disabled:!e.isAttrTrue(t.node,"enabled"),id:e.childId(t.path),optDesc:t.node,value:e.resolveValue(t.path)},on:{input:function(n){return e.onModified(t.path,n)}}}):e._e()]}))]}))],2)},i=[],o=(n("e260"),n("ddb0"),n("ca11")),r=n("4752"),s={name:"z42opt-container",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0}},methods:{childId(e){return r["c"](this.id,e,"#")},resolveOptDesc(e){if(null==e)return[];var t=0===e.length?this.optDesc:_.get(this.optDesc,e);if(t instanceof o["b"])return[{path:e,node:t}];var n=[];for(var a of Object.keys(t)){var i=r["c"](e,a);n=n.concat(this.resolveOptDesc(i))}return n},resolveValue(e){return _.get(this.optData,e)},isAttrTrue(e,t){var n=e.$attrs[t];return"undefined"===typeof n||("function"===typeof n?n(this.optData,this.optDesc):Boolean(n))},onModified(e,t){var n=_.get(this.optDesc,e);n instanceof o["b"]&&this.$emit("opt-modified",{path:e,value:t})}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},2216:function(e,t,n){"use strict";n("e260"),n("1276"),n("ddb0");var a=n("ca11"),i=n("094b"),o=n("4752"),r=n("dcbd");t["a"]=class extends a["b"]{constructor(e){super(e),this.position=new i["e"]({min:0,max:1,maxDecimals:3,defaultVal:0}),this.segment=new a["a"]({},{color:new i["b"]({title:"Selected color",defaultVal:{r:0,g:0,b:0,a:1}}),easeFun:new i["d"]({title:"Selected ease function",values:this.$attrs.easeFunctions,defaultVal:this.$attrs.defaultEaseFunction}),isNoisy:new i["a"]({title:"Add noise to lightness (HSL)",defaultVal:!1}),noise:new a["a"]({},{frequency:new i["f"]({shortKey:"f",title:"Frequency",min:1,max:15,maxDecimals:0,defaultVal:2,depends:e=>e.isNoisy}),octaves:new i["f"]({shortKey:"o",title:"Octaves",min:1,max:12,defaultVal:4,depends:e=>e.isNoisy}),gain:new i["e"]({shortKey:"g",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.5,depends:e=>e.isNoisy,enabled:e=>e.noise.octaves>=2}),lacunarity:new i["f"]({shortKey:"l",title:"Lacunarity",min:2,max:10,defaultVal:2,depends:e=>e.isNoisy,enabled:e=>e.noise.octaves>=2}),amplitude:new i["e"]({shortKey:"a",title:"Amplitude",min:0,max:5,maxDecimals:2,defaultVal:.5,depends:e=>e.isNoisy}),seed:new i["e"]({shortKey:"s",title:"Random seed",min:0,max:1,maxDecimals:2,defaultVal:.5,depends:e=>e.isNoisy})})}),o["f"](this.segment.noise,"palette.noise")}$serialize(e){var t="";for(var n of e)if(0===t.length||(t+=" "),t+=this.position.$serialize(n.pos)+"_",t+=this.segment.color.$serialize(n.color)+"_",t+=this.segment.easeFun.$serialize(n.easeFun),n.isNoisy){var a="";for(var i in this.segment.noise){0===a.length||(a+="*");var o=this.segment.noise[i];a+=o.$attrs.shortKey,a+=o.$serialize(n.noise[i])}t+="_"+a}return t}$deserialize(e){var t=[],n={};for(var a of(o["b"](n,this.segment.noise),e.split(" "))){var i=a.split("_");if(i.length>=2){var r={pos:this.position.$deserialize(i[0]),color:this.segment.color.$deserialize(i[1]),isNoisy:!1};if(i.length>=3&&(r.easeFun=this.segment.easeFun.$deserialize(i[2])),i.length>=4){r.isNoisy=!0,r.noise={};var s=i[3].split("*");for(var l in s){var c=s[l],u=c.substring(0,1),d=c.substring(1),h=n[u];if(h){var p=this.segment.noise[h].$deserialize(d);null!==p&&(r.noise[h]=p)}else console.error("Invalid shortKey for palette noise option:",u)}}t.push(r)}}return t}$resolveEaseFunction(e){return r[e]||r["linear"]}$resolvePaletteEaseFunctions(e){return e.map(e=>{var t=_.cloneDeep(e);return t.easeFun=this.$resolveEaseFunction(t.easeFun),t})}get $defaultComponent(){return"z42opt-palette"}}},2465:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{staticClass:"container px-0"},[n("b-row",{attrs:{"align-v":"center"}},[n("b-col",[n("label",{attrs:{for:e.id,disabled:e.disabled}},[e._v(" "+e._s(e.optDesc.$attrs.title)+": ")])]),n("b-col",[n("b-form-input",{staticClass:"z42opt-color",attrs:{type:"color",id:e.id,value:e.hexValue,disabled:e.disabled},on:{change:function(t){return e.onModified(t)}}})],1)],1)],1)},i=[],o=n("66cb"),r=n("ca11"),s={name:"z42opt-color",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:r["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created(){},computed:{hexValue(){return o(this.value).toHexString()}},methods:{onModified(e){this.$emit("input",o(e).toRgb())}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},"357f":function(e,t,n){},4752:function(e,t,n){"use strict";n.d(t,"d",(function(){return o})),n.d(t,"e",(function(){return r})),n.d(t,"c",(function(){return c})),n.d(t,"a",(function(){return u})),n.d(t,"f",(function(){return d})),n.d(t,"b",(function(){return p}));n("e260"),n("25f0"),n("1276"),n("ddb0"),n("2b3d");var a=n("ca11"),i=n("2ef0");function o(e,t){var n={};r(n,e),console.log("Default options:",JSON.parse(JSON.stringify(n)));var a=s(t,e);return a?(console.log("URL params:",JSON.parse(JSON.stringify(a))),i["defaultsDeep"](a,n),console.log("Merged options:",JSON.parse(JSON.stringify(a))),a):defaultValues}function r(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(!(t instanceof a["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");for(var[o,s]of Object.entries(t)){var l=c(n,o);if(s instanceof a["b"]){var u=s.$attrs.defaultVal;"undefined"===typeof u&&(console.error("Missing attribute defaultVal for option:",l),u=null),i["set"](e,l,u)}else r(e,s,l)}}function s(e,t){if(!(t instanceof a["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");var n={};d(t);var o={};p(o,t);var r=new URLSearchParams(e);for(var[s,l]of r){var c=o[s];if("undefined"!==typeof c){var u=i["get"](t,c);if(u instanceof a["b"]){var h=u.$deserialize(l);null!==h&&i["set"](n,c,h)}else console.error("Internal error: missing or invalid descriptor for URL param '".concat(s,"', path: ").concat(c))}else console.error("Invalid URL param '".concat(s,"'"))}return n}function l(e,t){if(!(t instanceof a["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");d(t);var n=new URLSearchParams;return f(n,e,t),n.toString()}function c(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return e&&0!=e.length?e+n+t:t}function u(e,t,n){var a=l(e,t),i=n.split("#")[0].split("?")[0];return i+"?"+a+"#"}function d(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=new Map;for(var[a,i]of(h(n,e,t),n.entries()))i.length>1&&console.error("Duplicate value '".concat(a,"' of attribute 'shortKey' detected for the following options:"),i)}function h(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;for(var[i,o]of Object.entries(t)){var r=c(n,i);if(o instanceof a["b"]){var s=o.$attrs.shortKey;if(!s){console.error("Missing attribute 'shortKey' for option:",r);continue}var l=s.toLowerCase();if(l!==s){console.error("Attribute 'shortKey' is not all lowercase for option:",r);continue}e.has(s)?e.get(s).push(r):e.set(s,[r])}else h(e,o,r)}}function p(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;for(var[i,o]of Object.entries(t)){var r=c(n,i);o instanceof a["b"]?e[o.$attrs.shortKey]=r:p(e,o,r)}}function f(e,t,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;for(var[r,s]of Object.entries(t)){var l=c(o,r),u=i["get"](n,l);if(u instanceof a["b"]){if(!1!==u.$attrs.serialize){if(!u.$attrs.shortKey){console.error("Missing attribute shortKey for option:",l);continue}var d=u.$serialize(s);e.append(u.$attrs.shortKey,d)}}else"object"===typeof s?f(e,s,n,l):console.error("Missing descriptor for option:",l)}}},"4af1":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-modal",{attrs:{id:e.id,title:e.optView.title,scrollable:"","hide-footer":""},on:{show:e.onShow,hide:e.onHide}},[n("p",[e.optView.moreInfoLinkUrl?n("a",{attrs:{href:e.optView.moreInfoLinkUrl,target:"_blank",rel:"noopener"}},[e._v(" "+e._s(e.optView.moreInfoLinkText)+" ")]):e._e(),n("a",{staticStyle:{float:"right"},attrs:{href:e.permaLinkUrl}},[e._v("Permalink")])]),n(e.optView.component||"z42opt-tabs",{tag:"component",attrs:{id:e.id,optData:e.optData,optDesc:e.optDesc,optView:e.optView,tabIndex:e.tabIndex},on:{"update:tabIndex":function(t){e.tabIndex=t},"update:tab-index":function(t){e.tabIndex=t},"opt-modified":function(t){return e.$emit("opt-modified",t)}}})],1)},i=[],o=n("ca11"),r=n("4752"),s={name:"z42opt-dialog",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0}},data(){return{initialPermaLinkUrl:null,tabIndex:0}},computed:{permaLinkUrl(){return r["a"](this.optData,this.optDesc,window.location.href)}},methods:{onShow(){this.initialPermaLinkUrl=r["a"](this.optData,this.optDesc,window.location.href)},onHide(){this.permaLinkUrl!==this.initialPermaLinkUrl&&window.history.pushState({action:"optionsDialogClose"},document.title,this.permaLinkUrl)}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},"4fc5":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.optDesc.$attrs.title+":","label-for":e.id,disabled:e.disabled}},[n("b-form-select",{staticClass:"z42opt-select",attrs:{id:e.id,options:e.options,value:e.value,disabled:e.disabled},on:{change:function(t){return e.$emit("input",t)}}})],1)},i=[],o=(n("e260"),n("ddb0"),n("ca11")),r={name:"z42opt-select",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created(){},computed:{options(){var e=Object.entries(this.optDesc.$attrs.values);return e.map(e=>({value:e[0],text:e[1].title||e[0]}))}}},s=r,l=n("2877"),c=Object(l["a"])(s,a,i,!1,null,null,null);t["default"]=c.exports},"56d7":function(e,t,n){"use strict";n.r(t);var a=n("2b0e"),i=n("5f5b");n("ab8b"),n("2dd8");a["default"].use(i["a"]);n("e260"),n("5319"),n("1276"),n("ddb0");var o=n("b8d7");o.keys().forEach(e=>{var t=o(e),n=e.split("/").pop().replace(/\.\w+$/,"");a["default"].component(n,t.default||t)});var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("b-button",{directives:[{name:"b-modal",rawName:"v-b-modal.z42opt-dialog",modifiers:{"z42opt-dialog":!0}}],attrs:{id:"button-options-dialog",title:"Plasma Options (Key 'o')"}},[e._v("⚙")]),n("z42opt-dialog",{attrs:{id:"z42opt-dialog",optData:e.optData,optDesc:e.optDesc,optView:e.optView},on:{"opt-modified":function(t){return e.onModified(t)}}}),e.optData.info.showFps?n("div",{attrs:{id:"fps-info"}}):e._e(),n("canvas",{staticClass:"plasma",attrs:{id:"plasmaCanvas"}},[e._v("PlasmaFractal")])],1)},s=[],l=(n("b680"),n("841c"),n("094b")),c=n("2216"),u={linear:{shortKey:"l",title:"Linear"},inQuad:{shortKey:"i2",title:"Quadratic [in]"},outQuad:{shortKey:"o2",title:"Quadratic [out]"},inOutQuad:{shortKey:"io2",title:"Quadratic [in/out]"},inCubic:{shortKey:"i3",title:"Cubic [in]"},outCubic:{shortKey:"o3",title:"Cubic [out]"},inOutCubic:{shortKey:"io3",title:"Cubic [in/out]"},inQuart:{shortKey:"i4",title:"Quartic [in]"},outQuart:{shortKey:"o4",title:"Quartic [out]"},inOutQuart:{shortKey:"io4",title:"Quartic [in/out]"},inQuint:{shortKey:"i5",title:"Quintic [in]"},outQuint:{shortKey:"o5",title:"Quintic [out]"},inOutQuint:{shortKey:"io5",title:"Quintic [in/out]"},inSine:{shortKey:"is",title:"Sine [in]"},outSine:{shortKey:"os",title:"Sine [out]"},inOutSine:{shortKey:"ios",title:"Sine [in/out]"},inOutSine2_3:{shortKey:"ios23",title:"Sine(x) + Sine(x*3)  [in/out]"},inOutSine2_5:{shortKey:"ios25",title:"Sine(x) + Sine(x*5)  [in/out]"},inOutSine2_9:{shortKey:"ios29",title:"Sine(x) + Sine(x*9)  [in/out]"},inOutSine2_13:{shortKey:"ios213",title:"Sine(x) + Sine(x*13) [in/out]"},inExpo:{shortKey:"ie",title:"Exponential [in]"},outExpo:{shortKey:"oe",title:"Exponential [out]"},inOutExpo:{shortKey:"ioe",title:"Exponential [in/out]"},inExpo2:{shortKey:"ie2",title:"Double Exponential [in]"},outExpo2:{shortKey:"oe2",title:"Double Exponential [out]"},inOutExpo2:{shortKey:"ioe2",title:"Double Exponential [in/out]"},inCirc:{shortKey:"ic",title:"Circular [in]"},outCirc:{shortKey:"oc",title:"Circular [out]"},inOutCirc:{shortKey:"ioc",title:"Circular [in/out]"},inBounce:{shortKey:"ib",title:"Bounce [in]"},outBounce:{shortKey:"ob",title:"Bounce [out]"},inOutBounce:{shortKey:"iob",title:"Bounce [in/out]"}},d={Perlin3D:{shortKey:"p3",title:"Perlin"},SimplexPerlin3D:{shortKey:"s3",title:"Simplex"},Value3D:{shortKey:"v3",title:"Value"},Cellular3D:{shortKey:"c3",title:"Cellular"}},h={warpRegular:{shortKey:"r",title:"Regular"},warpPolar:{shortKey:"p",title:"Polar"},warpVortex:{shortKey:"v",title:"Vortex"},warpVortexInverse:{shortKey:"vi",title:"Vortex Inverse"}},p=new l["g"]({},{noise:new l["g"]({},{noiseFunction:new l["d"]({shortKey:"n",title:"Noise function",values:d,defaultVal:"Perlin3D"}),frequency:new l["e"]({shortKey:"f",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:1.5}),octaves:new l["e"]({shortKey:"o",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:10}),gain:new l["e"]({shortKey:"g",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.5,enabled:e=>e.noise.octaves>1}),lacunarity:new l["e"]({shortKey:"l",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:e=>e.noise.octaves>1}),angle:new l["e"]({shortKey:"an",title:"Angle",min:0,max:90,maxDecimals:1,defaultVal:0,enabled:e=>e.noise.octaves>1}),amplitude:new l["e"]({shortKey:"a",title:"Amplitude",min:.1,max:50,isScale:!0,scaleNormalPos:.15,maxDecimals:2,defaultVal:1}),isClamp:new l["a"]({shortKey:"c",title:"Clamp",defaultVal:!1})}),warp:new l["g"]({},{isEnabled:new l["a"]({shortKey:"de",title:"Warp the noise",defaultVal:!1}),transformFunction:new l["d"]({shortKey:"wt",title:"Transform function",values:h,defaultVal:"warpVortex",depends:e=>e.warp.isEnabled}),noiseFunction:new l["d"]({shortKey:"wn",title:"Noise function",values:d,defaultVal:"Perlin3D",depends:e=>e.warp.isEnabled}),frequency:new l["e"]({shortKey:"wf",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:1.5,depends:e=>e.warp.isEnabled}),octaves:new l["e"]({shortKey:"wo",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:4,depends:e=>e.warp.isEnabled}),gain:new l["e"]({shortKey:"wg",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.75,enabled:e=>e.warp.octaves>1,depends:e=>e.warp.isEnabled}),lacunarity:new l["e"]({shortKey:"wl",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:e=>e.warp.octaves>1,depends:e=>e.warp.isEnabled}),amplitude:new l["e"]({shortKey:"wa",title:"Amplitude",min:1,max:100,maxDecimals:1,defaultVal:12,depends:e=>e.warp.isEnabled}),rotation:new l["e"]({shortKey:"wr",title:"Rotation",min:1,max:20,maxDecimals:1,defaultVal:4,depends:e=>e.warp.isEnabled&&"warpRegular"!=e.warp.transformFunction})}),warp2:new l["g"]({},{isEnabled:new l["a"]({shortKey:"de2",title:"Warp the warp",defaultVal:!1}),transformFunction:new l["d"]({shortKey:"wt2",title:"Transform function",values:h,defaultVal:"warpVortex",depends:e=>e.warp2.isEnabled}),noiseFunction:new l["d"]({shortKey:"wn2",title:"Noise function",values:d,defaultVal:"SimplexPerlin3D",depends:e=>e.warp2.isEnabled}),frequency:new l["e"]({shortKey:"wf2",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:3,depends:e=>e.warp2.isEnabled}),octaves:new l["e"]({shortKey:"wo2",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:4,depends:e=>e.warp2.isEnabled}),gain:new l["e"]({shortKey:"wg2",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.55,enabled:e=>e.warp2.octaves>1,depends:e=>e.warp2.isEnabled}),lacunarity:new l["e"]({shortKey:"wl2",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:e=>e.warp2.octaves>1,depends:e=>e.warp2.isEnabled}),amplitude:new l["e"]({shortKey:"wa2",title:"Amplitude",min:1,max:100,maxDecimals:1,defaultVal:3,depends:e=>e.warp2.isEnabled}),rotation:new l["e"]({shortKey:"wr2",title:"Rotation",min:1,max:20,maxDecimals:1,defaultVal:2,depends:e=>e.warp2.isEnabled&&"warp2Regular"!=e.warp2.transformFunction})}),palette:new l["g"]({},{isGrayScale:new l["a"]({shortKey:"pg",title:"Show only grayscale output",defaultVal:!1}),isCustom:new l["a"]({shortKey:"icp",title:"Custom palette",defaultVal:!1,depends:e=>!e.palette.isGrayScale}),easeFunctionBgToFg:new l["d"]({shortKey:"pbf",title:"Background to foreground easing",values:u,defaultVal:"inBounce",depends:e=>!e.palette.isCustom&&!e.palette.isGrayScale}),easeFunctionFgToBg:new l["d"]({shortKey:"pfb",title:"Foreground to background easing",values:u,defaultVal:"outBounce",depends:e=>!e.palette.isCustom&&!e.palette.isGrayScale}),saturation:new l["e"]({shortKey:"ps",title:"Saturation",min:0,max:1,maxDecimals:2,defaultVal:.5,depends:e=>!e.palette.isCustom&&!e.palette.isGrayScale}),brightness:new l["e"]({shortKey:"pb",title:"Brightness",min:0,max:1,maxDecimals:2,defaultVal:1,depends:e=>!e.palette.isCustom&&!e.palette.isGrayScale}),bgColor:new l["b"]({shortKey:"pbg",title:"Background color",defaultVal:{r:0,g:0,b:0,a:1},depends:e=>!e.palette.isCustom&&!e.palette.isGrayScale}),customPalette:new c["a"]({shortKey:"cp",easeFunctions:u,defaultEaseFunction:"linear",defaultVal:[],depends:e=>e.palette.isCustom&&!e.palette.isGrayScale}),isCustomPaletteAnimated:new l["a"]({shortKey:"acp",title:"Animate custom palette (random hue offset)",defaultVal:!1,depends:e=>e.palette.isCustom&&!e.palette.isGrayScale})}),noiseAnim:new l["g"]({},{isEnabled:new l["a"]({shortKey:"inm",title:"Mutate noise",defaultVal:!0}),noiseSpeed:new l["e"]({shortKey:"ns",title:"Noise mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:e=>e.noiseAnim.isEnabled}),turbulence:new l["e"]({shortKey:"ntu",title:"Noise turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:e=>e.noiseAnim.isEnabled})}),warpAnim:new l["g"]({},{isEnabled:new l["a"]({shortKey:"iwm",title:"Mutate warp",defaultVal:!1,depends:e=>e.warp.isEnabled}),noiseSpeed:new l["e"]({shortKey:"ws",title:"Warp mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:e=>e.warp.isEnabled&&e.warpAnim.isEnabled}),turbulence:new l["e"]({shortKey:"wtu",title:"Warp turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:e=>e.warp.isEnabled&&e.warpAnim.isEnabled})}),warpAnim2:new l["g"]({},{isEnabled:new l["a"]({shortKey:"iwm2",title:"Mutate warp²",defaultVal:!1,depends:e=>e.warp2.isEnabled}),noiseSpeed:new l["e"]({shortKey:"ws2",title:"Warp² mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:e=>e.warp2.isEnabled&&e.warpAnim2.isEnabled}),turbulence:new l["e"]({shortKey:"wtu2",title:"Warp² turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:e=>e.warp2.isEnabled&&e.warpAnim2.isEnabled})}),paletteAnim:new l["g"]({},{isRotaEnabled:new l["a"]({shortKey:"ipr",title:"Rotate palette (disabled if Noise > Clamp is set)",defaultVal:!1,enabled:e=>!e.noise.isClamp}),rotaSpeed:new l["e"]({shortKey:"prs",title:"Palette rotation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.1,depends:e=>e.paletteAnim.isRotaEnabled&&!e.noise.isClamp}),transitionDelay:new l["c"]({shortKey:"ptde",title:"Palette transition delay",min:0,max:30,displayUnit:"s",maxDecimals:1,isSlow:!0,defaultVal:10,depends:e=>!e.palette.isCustom||e.palette.isCustomPaletteAnimated}),transitionDuration:new l["c"]({shortKey:"ptd",title:"Palette transition duration",min:.1,max:30,displayUnit:"s",maxDecimals:1,isSlow:!0,defaultVal:5,depends:e=>!e.palette.isCustom||e.palette.isCustomPaletteAnimated})}),info:new l["g"]({},{showFps:new l["a"]({shortKey:"sfp",title:"Show FPS",defaultVal:!1,serialize:!1})})}),f={title:"PlasmaFractal Options",moreInfoLinkUrl:"https://github.com/zett42/plasmafractal-gl",moreInfoLinkText:"GitHub Project",groups:{noiseTab:{title:"Noise",options:["noise"]},warpingTab:{title:"Warp",options:["warp"]},warpingTab2:{title:"Warp²",options:["warp2"]},paletteTab:{title:"Palette",options:["palette"]},animTab:{title:"Animation",options:["noiseAnim","warpAnim","warpAnim2","paletteAnim"]},infoTab:{title:"Info",options:["info"]}}},m=n("4752"),v=n("ade3"),g=n("2aaf"),_=n.n(g),w=n("66cb"),b=n("2ef0"),y=n("28dd"),E=n.n(y),x=n("e2a2"),P=n.n(x),S=n("be4d"),I=n("dcbd");n("ace4"),n("cfc3"),n("b39a");function O(e,t,n,a,i){var o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:e.STATIC_DRAW,r=t,s=t+a,l=n,c=n+i;e.bufferData(e.ARRAY_BUFFER,new Float32Array([r,l,s,l,r,c,r,c,s,l,s,c]),o)}n("c19f"),n("5cc6"),n("fb2c");function T(e,t,n,a){t=Math.trunc(t);var i=new ArrayBuffer(4*t),o=new Uint32Array(i);S["e"](o,o.length,n);for(var r=0;t>=1;++r){var s=new Uint8Array(i);e.texImage2D(e.TEXTURE_2D,r,e.RGBA,t,1,0,e.RGBA,e.UNSIGNED_BYTE,s,0);var l=Math.trunc(t/2);if(l>=1){for(var c=new ArrayBuffer(4*l),u=new Uint32Array(c),d=0,h=0;d<l;++d,h+=2){var p=D(o,h-1,a),f=D(o,h+0,a),m=D(o,h+1,a),v=z(R(N([p,f,m]),1/3));u[d]=v.a<<24|v.r<<16|v.g<<8|v.b}i=c,o=u}t=l}e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,a?e.REPEAT:e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR)}function A(e){return{a:e>>24,r:e>>16&255,g:e>>8&255,b:255&e}}function N(e){var t={a:0,r:0,g:0,b:0};for(var n of e)t.a+=n.a,t.r+=n.r,t.g+=n.g,t.b+=n.b;return t}function R(e,t){return{a:e.a*t,r:e.r*t,g:e.g*t,b:e.b*t}}function z(e){return{a:Math.round(e.a),r:Math.round(e.r),g:Math.round(e.g),b:Math.round(e.b)}}function D(e,t,n){var a=n?S["c"](t,e.length):S["b"](t,0,e.length-1);return A(e[a])}var F="#version 300 es\n\n#define SHADER_NAME glPlasmaVertex.glsl\n\nprecision highp float;\n#define GLSLIFY 1\n\n// Scale factor to adjust for screen aspect ratio and orientation.\nuniform vec2 u_scale;\n\n// An attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec2 a_position;\nin vec2 a_texCoord;\n\n// Used to pass the texture coordinates to the fragment shader\nout vec2 fragCoord;\n\nvoid main() {\n\t// Scale to adjust for screen aspect ratio and orientation.\n\tvec2 pos = a_position * u_scale;\n\n\t// Define position of the current vertex by assigning to global variable gl_Position \n\tgl_Position = vec4( pos, 0, 1 );\n\n\t// pass the texCoord to the fragment shader\n\t// The GPU will interpolate this value between points.\n\tfragCoord = a_texCoord;\n}",C='#version 300 es\n#define SHADER_NAME glPlasmaFrag.glsl\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fragment shaders don\'t have a default precision so we need to pick one.\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\n//·············································································································\n// Imports\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson\'s and Ian McEwan\'s work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Value Noise 3D\n//  Return value range of -1.0->1.0 (modification by zett42, original code: 0.0->1.0)\n//\nfloat Value3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float result = dot( res0, blend2.zxzx * blend2.wwyy );\n\t\n\treturn result * 2.0 - 1.0;\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This represents a modified version of Stefan Gustavson\'s work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//  The noise is optimized to use a 2x2x2 search window instead of 3x3x3\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - random point offset is restricted to prevent artifacts\n//\n\n//\n//  Cellular Noise 3D\n//  produces a range of 0.0->1.0\n//\nfloat Cellular3D(vec3 P)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash ( over -1.0->1.0 range )\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hash_x0 = fract( Pt * lowz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_x1 = fract( Pt * highz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_y0 = fract( Pt * lowz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_y1 = fract( Pt * highz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_z0 = fract( Pt * lowz_mod.zzzz ) * 2.0 - 1.0;\n    vec4 hash_z1 = fract( Pt * highz_mod.zzzz ) * 2.0 - 1.0;\n\n    //  generate the 8 point positions\n    const float JITTER_WINDOW = 0.166666666;\t// 0.166666666 will guarentee no artifacts.\n    hash_x0 = ( ( hash_x0 * hash_x0 * hash_x0 ) - sign( hash_x0 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y0 = ( ( hash_y0 * hash_y0 * hash_y0 ) - sign( hash_y0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_x1 = ( ( hash_x1 * hash_x1 * hash_x1 ) - sign( hash_x1 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y1 = ( ( hash_y1 * hash_y1 * hash_y1 ) - sign( hash_y1 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_z0 = ( ( hash_z0 * hash_z0 * hash_z0 ) - sign( hash_z0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 0.0, 0.0 );\n    hash_z1 = ( ( hash_z1 * hash_z1 * hash_z1 ) - sign( hash_z1 ) ) * JITTER_WINDOW + vec4( 1.0, 1.0, 1.0, 1.0 );\n\n    //\treturn the closest squared distance\n    vec4 dx1 = Pf.xxxx - hash_x0;\n    vec4 dy1 = Pf.yyyy - hash_y0;\n    vec4 dz1 = Pf.zzzz - hash_z0;\n    vec4 dx2 = Pf.xxxx - hash_x1;\n    vec4 dy2 = Pf.yyyy - hash_y1;\n    vec4 dz2 = Pf.zzzz - hash_z1;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;\n    d1 = min(d1, d2);\n    d1.xy = min(d1.xy, d1.wz);\n    return min(d1.x, d1.y) * ( 9.0 / 12.0 ); // return a value scaled to 0.0->1.0\n}\n\n// Common parameter types\nstruct FbmNoiseParams {\n\tint   octaves;           // number of octaves for fractal noise\n\tfloat octavesFract;      // fractional part of octaves value\n\tfloat frequency;         // noise frequency\n\tfloat gain;              // amplitude factor per octave\n\tfloat angle;             // rotation per octave\n\tfloat lacunarity;        // frequency factor per octave\n\tfloat turbulence;        // Z coordinate factor per octave  \n};\n\nstruct NoiseParams {\n\tFbmNoiseParams basic;    // basic params\n\tfloat anim;              // Z-position in 3D noise, for animation\n\tfloat amplitude;         // noise amplitude\n};\n\nstruct WarpParams {\n\tFbmNoiseParams basic;\n\tfloat anim;              // Z-position in 3D noise, for animation\n\tfloat amplitude;         // directional amplitude\n\tfloat rotation;          // rotational amplitude\n};\n\n// Through preprocessor variables BASE_NOISE_FUN, WARP_NOISE_FUN and WARP2_NOISE_FUN which are passed from JS \n// via injectDefines(), we select from the above noise functions to compose the FBM functions.\n// NOTE: formatting should not be changed, as glslify breaks when more than 1 space character appears after comma!\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_0( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p2 = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += BASE_NOISE_FUN( vec3( p2, z ) ) * amp;\n\n\t\tp2  *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += BASE_NOISE_FUN( vec3( p2, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_2( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p2 = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += WARP_NOISE_FUN( vec3( p2, z ) ) * amp;\n\n\t\tp2  *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += WARP_NOISE_FUN( vec3( p2, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// This variant returns two different noise values for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec2 fbmNoiseDual3D_0( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec2 result = vec2( 0 );\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.0;\n\n\t// Randomize noise for Y direction.\n\tconst float yInc = 4.8;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tvec3 p = vec3( pos.xy * freq, z );\n\t\tfloat nx = WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\t\tfloat ny = WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\t\tresult += vec2( nx, ny ) * amp;\n\n\t\tfreq   *= noise.lacunarity;\n\t\tamp    *= noise.gain;\n\t\tz      += zInc;\n\t\tz      *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tvec3 p = vec3( pos.xy * freq, z );\n\tfloat nx = WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\tfloat ny = WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\tresult += vec2( nx, ny ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n// Regular domain warping. Just offset coordinates by noise values.\n\nvec2 warpRegular_0( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_0( vec3( pos, warp.anim ), warp.basic );\n\t\t\t\t\t\t\t\t\t  \n\treturn pos + noise * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are interpreting the noise values as angle and length to\n// produce more fluid-looking results. \n\nvec2 warpPolar_0( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_0( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat warpAngle = noise.x * warp.rotation;\n\treturn pos.xy + vec2( sin( warpAngle ), cos( warpAngle ) ) * noise.y * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are using the noise value for a vortex (spiral) transformation.\n// Creates results similar to warpPolar, but requires only a single noise function, reducing GPU load!\n\nvec2 warpVortex_0( vec2 pos, WarpParams warp ) {\n\t\n\tfloat noise = fbmNoise3D_2( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Variation of warpVortex. \n\nvec2 warpVortexInverse_0( vec2 pos, WarpParams warp ) {\n\n\tfloat noise = fbmNoise3D_2( vec3( pos, warp.anim ), warp.basic );\n\n\tnoise = 1.0 - abs( clamp( noise, -1.0, 1.0 ) );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_1( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p2 = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += WARP2_NOISE_FUN( vec3( p2, z ) ) * amp;\n\n\t\tp2  *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += WARP2_NOISE_FUN( vec3( p2, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// This variant returns two different noise values for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec2 fbmNoiseDual3D_1( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec2 result = vec2( 0 );\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.0;\n\n\t// Randomize noise for Y direction.\n\tconst float yInc = 4.8;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tvec3 p = vec3( pos.xy * freq, z );\n\t\tfloat nx = WARP2_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\t\tfloat ny = WARP2_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\t\tresult += vec2( nx, ny ) * amp;\n\n\t\tfreq   *= noise.lacunarity;\n\t\tamp    *= noise.gain;\n\t\tz      += zInc;\n\t\tz      *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tvec3 p = vec3( pos.xy * freq, z );\n\tfloat nx = WARP2_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\tfloat ny = WARP2_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\tresult += vec2( nx, ny ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n// Regular domain warping. Just offset coordinates by noise values.\n\nvec2 warpRegular_1( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_1( vec3( pos, warp.anim ), warp.basic );\n\t\t\t\t\t\t\t\t\t  \n\treturn pos + noise * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are interpreting the noise values as angle and length to\n// produce more fluid-looking results. \n\nvec2 warpPolar_1( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_1( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat warpAngle = noise.x * warp.rotation;\n\treturn pos.xy + vec2( sin( warpAngle ), cos( warpAngle ) ) * noise.y * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are using the noise value for a vortex (spiral) transformation.\n// Creates results similar to warpPolar, but requires only a single noise function, reducing GPU load!\n\nvec2 warpVortex_1( vec2 pos, WarpParams warp ) {\n\t\n\tfloat noise = fbmNoise3D_1( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Variation of warpVortex. \n\nvec2 warpVortexInverse_1( vec2 pos, WarpParams warp ) {\n\n\tfloat noise = fbmNoise3D_1( vec3( pos, warp.anim ), warp.basic );\n\n\tnoise = 1.0 - abs( clamp( noise, -1.0, 1.0 ) );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n//·············································································································\n// Wrapper functions so we can select from the functions at runtime, without having to know the suffix\n// that is added by glslify to the \'require\'d functions, which it does to avoid duplicate identifiers.\n\nvec2 warpRegular( vec2 pos, WarpParams warp )        { return warpRegular_0( pos, warp ); }\nvec2 warpPolar( vec2 pos, WarpParams warp )          { return warpPolar_0( pos, warp ); }\nvec2 warpVortex( vec2 pos, WarpParams warp )         { return warpVortex_0( pos, warp ); }\nvec2 warpVortexInverse( vec2 pos, WarpParams warp )  { return warpVortexInverse_0( pos, warp ); }\n\nvec2 warpRegular2( vec2 pos, WarpParams warp )       { return warpRegular_1( pos, warp ); }\nvec2 warpPolar2( vec2 pos, WarpParams warp )         { return warpPolar_1( pos, warp ); }\nvec2 warpVortex2( vec2 pos, WarpParams warp )        { return warpVortex_1( pos, warp ); }\nvec2 warpVortexInverse2( vec2 pos, WarpParams warp ) { return warpVortexInverse_1( pos, warp ); }\n\n//·············································································································\n\nfloat clampZeroOne( float value ) {\n\treturn clamp( value, 0.0, 1.0 );\n}\n\n//·············································································································\n\nfloat mapToPaletteMinusOneToOne( float value ) {\n\treturn value / 2.0 + 0.5;\t\n}\n\n//·············································································································\n// Identity functions to switch off certain effects.\n\nfloat identity( float value ) {\treturn value; }\n\nvec2 identity( vec2 value ) { return value; }\n\nvec2 identity( vec2 value, WarpParams warp ) { return value; }\n\n//·············································································································\n// Shader parameters\n\n// Regular noise parameters.\nuniform NoiseParams u_noise;\n\n// Domain warping parameters.\nuniform WarpParams u_warp;\nuniform WarpParams u_warp2;\n\n// Texture that defines the palette.\nuniform sampler2D u_paletteTexture;\nuniform float     u_paletteOffset;     // offset for palette rotation animation\n\n// Fragment coordinates passed in from the vertex shader.\nin vec2 fragCoord;\n\n// Output of this fragment shader.\nout vec4 fragColor;\n\n//·············································································································\n\nvoid main() { \n\n\tvec2 pos = fragCoord.xy;\n\n\tpos = WARP2_TRANSFORM_FUN( pos, u_warp2 );\n\tpos = WARP_TRANSFORM_FUN( pos, u_warp );\n\n\tfloat n = fbmNoise3D_0( vec3( pos, u_noise.anim ), u_noise.basic ) * u_noise.amplitude;\n\t\t\t\t\t\t\n\t// Adjust for differences in noise function range (-1..1 or 0..1).\n\tn = MAP_TO_PALETTE_FUN( n );\n\n\t// Optionally clamp to 0..1\n\tn = NOISE_CLAMP_FUN( n );\n\n\t// Actual color is defined by palette\n\tfragColor = texture( u_paletteTexture, vec2( n + u_paletteOffset, 0 ) );\n}';function M(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function L(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?M(n,!0).forEach((function(t){Object(v["a"])(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):M(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}class V{constructor(e){this._noiseSeed=e.noiseSeed,this._warpSeed=e.warpSeed,this._warpSeed2=e.warpSeed2,this._options=b["cloneDeep"](e.options),this._startTime=performance.now()/1e3,this._initPalettes(e.colorSeed),this._initCanvasGl(e.canvas),this.resize(e.width,e.height,!0)}_initPalettes(e){this._paletteRndColorCount=2,this._startPalette=[],this._nextPalette=[],this._currentPalette=[],this._grayScalePalette=[{pos:0,color:{r:0,g:0,b:0,a:1},easeFun:I["linear"]},{pos:1,color:{r:255,g:255,b:255,a:1},easeFun:I["linear"]}],this._paletteCurrentFirstHue=0,this._colorRnd=new _.a(Math.trunc(4294967295*e)),this._startPalette=this._generatePalette(360*this._colorRnd.random()),this._isPaletteTransition=!1,this._paletteStartTime=this._startTime,this._currentPaletteIsRepeat=null}_initCanvasGl(e){this._canvas=e;var t=this._gl=e.getContext("webgl2");t.disable(t.BLEND),t.disable(t.DEPTH_TEST),t.depthMask(t.FALSE),t.stencilMask(t.FALSE),this._positionBuffer=t.createBuffer(),this._texCoordBuffer=t.createBuffer(),this._paletteTexture=t.createTexture(),this._paletteTextureSize=Math.min(t.getParameter(t.MAX_TEXTURE_SIZE),32768),this._rebuildShaders()}_rebuildShaders(){var e="mapToPaletteMinusOneToOne";"Cellular3D"==this._options.noise.noiseFunction&&(e="identity");var t=P()(C,{BASE_NOISE_FUN:this._options.noise.noiseFunction,NOISE_CLAMP_FUN:this._options.noise.isClamp?"clampZeroOne":"identity",MAP_TO_PALETTE_FUN:e,WARP_NOISE_FUN:this._options.warp.noiseFunction,WARP_TRANSFORM_FUN:this._options.warp.isEnabled?this._options.warp.transformFunction:"identity",WARP2_NOISE_FUN:this._options.warp2.noiseFunction,WARP2_TRANSFORM_FUN:this._options.warp2.isEnabled?"".concat(this._options.warp2.transformFunction,"2"):"identity"});console.log("fragShaderSrcTransformed: ",t),this._shader?this._shader.update(F,t):this._shader=E()(this._gl,F,t),this._updateStaticShaderData()}_updateStaticShaderData(){this._shader.bind(),this._updateShaderVar_coords(),this._updateShaderVar_scale()}_updateShaderVar_coords(){var e=this._gl;this._vao&&e.deleteVertexArray(this._vao),this._vao=e.createVertexArray(),e.bindVertexArray(this._vao),e.bindBuffer(e.ARRAY_BUFFER,this._positionBuffer),O(e,-1,-1,2,2),this._shader.attributes.a_position.pointer(e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this._texCoordBuffer),O(e,-1,-1,2,2),this._shader.attributes.a_texCoord.pointer(e.FLOAT,!1,0,0),e.bindVertexArray(null)}_updateShaderVar_scale(){var e=this._canvas.width,t=this._canvas.height;e>t?t>0&&(this._shader.uniforms.u_scale=[1,e/t]):e>0&&(this._shader.uniforms.u_scale=[t/e,1])}resize(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];(e!=this._canvas.width||t!=this._canvas.height||n)&&(e<=0||t<=0||(e=Math.trunc(e),t=Math.trunc(t),this._canvas.width=e,this._canvas.height=t,this._gl.viewport(0,0,e,t),this._updateShaderVar_scale()))}drawAnimationFrame(){var e=performance.now()/1e3-this._startTime,t=this._gl;this._shader.bind(),this.setShaderArgs_noise("u_noise",this._options.noise,this._options.noiseAnim,this._noiseSeed,e),this._options.warp.isEnabled&&this.setShaderArgs_warp("u_warp",this._options.warp,this._options.warpAnim,this._warpSeed,e),this._options.warp2.isEnabled&&this.setShaderArgs_warp("u_warp2",this._options.warp2,this._options.warpAnim2,this._warpSeed2,e),this.setShaderArgs_palette(e),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.bindVertexArray(this._vao),t.drawArrays(t.TRIANGLES,0,6)}setShaderArgs_noise(e,t,n,a,i){var o=this._shader.uniforms[e];o.basic.octaves=Math.trunc(this._options.noise.octaves),o.basic.octavesFract=this._options.noise.octaves%1,o.basic.frequency=this._options.noise.frequency/2,o.basic.gain=this._options.noise.gain,o.basic.lacunarity=this._options.noise.lacunarity,o.basic.angle=2*this._options.noise.angle*Math.PI/360,o.amplitude=this._options.noise.amplitude;var r=50*this._noiseSeed,s=1;this._options.noiseAnim.isEnabled&&(r+=i*this._options.noiseAnim.noiseSpeed/3,s=this._options.noiseAnim.turbulence),o.anim=r,o.basic.turbulence=s}setShaderArgs_warp(e,t,n,a,i){var o=this._shader.uniforms[e];o.basic.octaves=Math.trunc(t.octaves),o.basic.octavesFract=t.octaves%1,o.basic.frequency=t.frequency*this._options.noise.frequency,o.basic.gain=t.gain,o.basic.lacunarity=t.lacunarity,o.amplitude=.01*t.amplitude,o.rotation=t.rotation*Math.PI;var r=50*a,s=1;n.isEnabled&&(r+=i*n.noiseSpeed/3,s=n.turbulence),o.anim=r,o.basic.turbulence=s}setShaderArgs_palette(e){var t=this._gl;if(this._options.paletteAnim.isRotaEnabled&&!this._options.noise.isClamp){var n=this._paletteTextureSize/4096;this._shader.uniforms.u_paletteOffset=e*this._options.paletteAnim.rotaSpeed*n}else this._shader.uniforms.u_paletteOffset=0;this._shader.uniforms.u_paletteTexture=0;var a=this._grayScalePalette;this._options.palette.isGrayScale||(a=this._animatePalette()),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._paletteTexture);var i=!this._options.noise.isClamp;b["isEqual"]([this._currentPalette,this._currentPaletteIsRepeat],[a,i])||(this._currentPalette=b["cloneDeep"](a),this._currentPaletteIsRepeat=i,T(t,this._paletteTextureSize,a,i))}get options$noise(){return b["cloneDeep"](this._options.noise)}set options$noise(e){var t=!b["isEqual"]([this._options.noise.noiseFunction,this._options.noise.isClamp],[e.noiseFunction,e.isClamp]);this._options.noise=b["cloneDeep"](e),t&&this._rebuildShaders()}get options$warp(){return b["cloneDeep"](this._options.warp)}set options$warp(e){var t=!b["isEqual"]([this._options.warp.isEnabled,this._options.warp.noiseFunction,this._options.warp.transformFunction],[e.isEnabled,e.noiseFunction,e.transformFunction]);this._options.warp=b["cloneDeep"](e),t&&this._rebuildShaders()}get options$warp2(){return b["cloneDeep"](this._options.warp2)}set options$warp2(e){var t=!b["isEqual"]([this._options.warp2.isEnabled,this._options.warp2.noiseFunction,this._options.warp2.transformFunction],[e.isEnabled,e.noiseFunction,e.transformFunction]);this._options.warp2=b["cloneDeep"](e),t&&this._rebuildShaders()}get options$palette(){return b["cloneDeep"](this._options.palette)}set options$palette(e){this._options.palette=b["cloneDeep"](e),this._startPalette=this._generatePalette(this._paletteCurrentFirstHue),this._isPaletteTransition=!1,this._paletteStartTime=performance.now()/1e3}get options$paletteAnim(){return b["cloneDeep"](this._options.paletteAnim)}set options$paletteAnim(e){e.transitionDelay==this._options.paletteAnim.transitionDelay&&e.transitionDuration==this._options.paletteAnim.transitionDuration||(this._isPaletteTransition=!1,this._paletteStartTime=performance.now()/1e3),this._options.paletteAnim=b["cloneDeep"](e)}get options$noiseAnim(){return b["cloneDeep"](this._options.noiseAnim)}set options$noiseAnim(e){this._options.noiseAnim=b["cloneDeep"](e)}get options$warpAnim(){return b["cloneDeep"](this._options.warpAnim)}set options$warpAnim(e){this._options.warpAnim=b["cloneDeep"](e)}get options$warpAnim2(){return b["cloneDeep"](this._options.warpAnim2)}set options$warpAnim2(e){this._options.warpAnim2=b["cloneDeep"](e)}_animatePalette(){var e=performance.now()/1e3,t=e-this._paletteStartTime;if(this._isPaletteTransition){if(t<=this._options.paletteAnim.transitionDuration){var n=t/this._options.paletteAnim.transitionDuration;return S["a"](this._startPalette,this._nextPalette,n)}return this._isPaletteTransition=!1,this._paletteStartTime=e,[this._startPalette,this._nextPalette]=[this._nextPalette,this._startPalette],this._startPalette}return t>this._options.paletteAnim.transitionDelay&&(this._isPaletteTransition=!0,this._paletteStartTime=e,this._nextPalette=this._generatePalette(360*this._colorRnd.random())),this._startPalette}_generatePalette(e){return this._paletteCurrentFirstHue=e,this._options.palette.isCustom?this._generatePaletteCustom(e):this._generatePaletteRandom(e)}_generatePaletteCustom(e){var t=this._options.palette.customPalette.map(e=>{var t=b["cloneDeep"](e);return t.easeFun=I[t.easeFun]||I["linear"],t});if(this._options.palette.isCustomPaletteAnimated)for(var n of t){var a=w(n.color).toHsv();a.h=(a.h+e)%360,n.color=w(a).toRgb()}return t}_generatePaletteRandom(e){for(var t=[],n={h:e,s:this._options.palette.saturation,v:this._options.palette.brightness,a:1},a=I[this._options.palette.easeFunctionBgToFg],i=I[this._options.palette.easeFunctionFgToBg],o=1/this._paletteRndColorCount,r=o/2,s=0;s<this._paletteRndColorCount;++s){var l=S["d"](n);t.push({pos:s*o,color:L({},this._options.palette.bgColor),easeFun:a||I["linear"]}),t.push({pos:s*o+r,color:l,easeFun:i||I["linear"]})}return t}}var H=m["d"](p,window.location.search),U=null,W=null,$=null,K=performance.now(),B=0,q={name:"app",data(){return{optData:H,optDesc:p,optView:f}},mounted(){U=document.getElementById("plasmaCanvas"),W=new V({canvas:U,colorSeed:Math.random(),noiseSeed:Math.random(),warpSeed:Math.random(),warpSeed2:Math.random(),options:H,width:Math.round(window.innerWidth*window.devicePixelRatio),height:Math.round(window.innerHeight*window.devicePixelRatio)}),G(),requestAnimationFrame(k)},methods:{onModified(e){b["set"](H,e.path,e.value);var t=e.path.split(".")[0];W["options$"+t]=H[t]}}};function G(){window.addEventListener("resize",b["debounce"](Y,150)),window.addEventListener("popstate",()=>window.location.reload()),document.addEventListener("fullscreenchange",X),document.addEventListener("mousemove",X),document.addEventListener("click",X),document.addEventListener("keydown",Z),U.addEventListener("dblclick",Q)}function k(){W.drawAnimationFrame(),j(),requestAnimationFrame(k)}function j(){++B;var e=performance.now();if(e-K>=1e3){var t=document.getElementById("fps-info");t&&(t.textContent=B.toFixed(0)+" fps"),K=e,B=0}}function Y(){var e=Math.round(window.innerWidth*window.devicePixelRatio),t=Math.round(window.innerHeight*window.devicePixelRatio);W.resize(e,t)}function Q(){document.documentElement.requestFullscreen&&(document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen())}function X(){document.getElementById("button-options-dialog").style.opacity=1,$&&clearTimeout($),document.fullscreenElement&&($=setTimeout(()=>document.getElementById("button-options-dialog").style.opacity=0,2e3))}function Z(e){if(!e.isComposing)switch(e.keyCode){case"O".charCodeAt(0):document.getElementById("button-options-dialog").click();break}}var J=q,ee=n("2877"),te=Object(ee["a"])(J,r,s,!1,null,null,null),ne=te.exports;n("357f");a["default"].config.productionTip=!1,new a["default"]({render:e=>e(ne)}).$mount("#app")},"93b8":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.optDesc.$attrs.title+": "+e.displayValue,"label-for":e.id,disabled:e.disabled}},[n("div",{staticClass:"z42opt-range",attrs:{id:e.id,disabled:e.disabled}})])},i=[],o=(n("e260"),n("ddb0"),n("ca11")),r=n("e9fa"),s=n.n(r),l=(n("c0a8"),new WeakMap),c={name:"z42opt-range",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{type:Number,required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},mounted(){var e=this;l.set(this,{sliderValue:this.value});var t=this.getSliderElement();s.a.create(t,this.createSliderConfig());var n=this.optDesc.$attrs.isSlow?"change":"slide";t.noUiSlider.on(n,(function(){return e.onSlide(...arguments)}))},computed:{displayValue(){return this.optDesc.$displayValue(this.value)}},methods:{getSliderElement(){return document.getElementById(this.id)},createSliderConfig(){var e=1;null!=this.optDesc.$attrs.step?e=this.optDesc.$attrs.step:null!=this.optDesc.$attrs.maxDecimals&&(e=1/Math.pow(10,this.optDesc.$attrs.maxDecimals));var t={min:this.optDesc.$attrs.min,max:this.optDesc.$attrs.max};if(this.optDesc.$attrs.isScale){var n=50;null!=this.optDesc.$attrs.scaleNormalPos&&(n=100*this.optDesc.$attrs.scaleNormalPos),t["".concat(n,"%")]=1}var a={to:e=>this.optDesc.$displayValue(e)};return{start:[this.value],step:e,range:t,behaviour:"unconstrained",tooltips:!!this.optDesc.$attrs.isSlow&&a}},onSlide(e,t,n,a,i){var o=l.get(this),r=n[0];o.sliderValue!==r&&(o.sliderValue=r,this.$emit("input",r))}},watch:{value(e,t){var n=l.get(this);if(n.sliderValue!==e){n.sliderValue=e;var a=this.getSliderElement();a.noUiSlider.set([e])}}}},u=c,d=n("2877"),h=Object(d["a"])(u,a,i,!1,null,null,null);t["default"]=h.exports},b8d7:function(e,t,n){var a={"./z42opt-check.vue":"0388","./z42opt-color.vue":"2465","./z42opt-container.vue":"11f2","./z42opt-dialog.vue":"4af1","./z42opt-palette.vue":"0954","./z42opt-range.vue":"93b8","./z42opt-select.vue":"4fc5","./z42opt-tabs.vue":"fc79"};function i(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=o,e.exports=i,i.id="b8d7"},be4d:function(e,t,n){"use strict";n("e260"),n("4e82"),n("ddb0");var a=n("66cb");class i{constructor(e,t,n){this.x=e,this.y=t,this.z=n}dot2(e,t){return this.x*e+this.y*t}dot3(e,t,n){return this.x*e+this.y*t+this.z*n}}function o(e){return e*e*e*(e*(6*e-15)+10)}function r(e,t,n){return(1-n)*e+n*t}var s=[new i(1,1,0),new i(-1,1,0),new i(1,-1,0),new i(-1,-1,0),new i(1,0,1),new i(-1,0,1),new i(1,0,-1),new i(-1,0,-1),new i(0,1,1),new i(0,-1,1),new i(0,1,-1),new i(0,-1,-1)],l=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],c=.5*(Math.sqrt(3)-1),u=(3-Math.sqrt(3))/6,d=1/3,h=1/6,p=class{constructor(e){this._perm=new Array(512),this._gradP=new Array(512),this.seed=e}set seed(e){if(e!==this._seed){this._seed=e,e>0&&e<1&&(e*=65536),e=Math.floor(e),e<256&&(e|=e<<8);for(var t=0;t<256;t++){var n=void 0;n=1&t?l[t]^255&e:l[t]^e>>8&255,this._perm[t]=this._perm[t+256]=n,this._gradP[t]=this._gradP[t+256]=s[n%12]}}}get seed(){return this._seed}simplex2(e,t){var n,a,i,o,r,s=(e+t)*c,l=Math.floor(e+s),d=Math.floor(t+s),h=(l+d)*u,p=e-l+h,f=t-d+h;p>f?(o=1,r=0):(o=0,r=1);var m=p-o+u,v=f-r+u,g=p-1+2*u,_=f-1+2*u;l&=255,d&=255;var w=this._gradP[l+this._perm[d]],b=this._gradP[l+o+this._perm[d+r]],y=this._gradP[l+1+this._perm[d+1]],E=.5-p*p-f*f;E<0?n=0:(E*=E,n=E*E*w.dot2(p,f));var x=.5-m*m-v*v;x<0?a=0:(x*=x,a=x*x*b.dot2(m,v));var P=.5-g*g-_*_;return P<0?i=0:(P*=P,i=P*P*y.dot2(g,_)),70*(n+a+i)}simplex3(e,t,n){var a,i,o,r,s,l,c,u,p,f,m=(e+t+n)*d,v=Math.floor(e+m),g=Math.floor(t+m),_=Math.floor(n+m),w=(v+g+_)*h,b=e-v+w,y=t-g+w,E=n-_+w;b>=y?y>=E?(s=1,l=0,c=0,u=1,p=1,f=0):b>=E?(s=1,l=0,c=0,u=1,p=0,f=1):(s=0,l=0,c=1,u=1,p=0,f=1):y<E?(s=0,l=0,c=1,u=0,p=1,f=1):b<E?(s=0,l=1,c=0,u=0,p=1,f=1):(s=0,l=1,c=0,u=1,p=1,f=0);var x=b-s+h,P=y-l+h,S=E-c+h,I=b-u+2*h,O=y-p+2*h,T=E-f+2*h,A=b-1+3*h,N=y-1+3*h,R=E-1+3*h;v&=255,g&=255,_&=255;var z=this._gradP[v+this._perm[g+this._perm[_]]],D=this._gradP[v+s+this._perm[g+l+this._perm[_+c]]],F=this._gradP[v+u+this._perm[g+p+this._perm[_+f]]],C=this._gradP[v+1+this._perm[g+1+this._perm[_+1]]],M=.6-b*b-y*y-E*E;M<0?a=0:(M*=M,a=M*M*z.dot3(b,y,E));var L=.6-x*x-P*P-S*S;L<0?i=0:(L*=L,i=L*L*D.dot3(x,P,S));var V=.6-I*I-O*O-T*T;V<0?o=0:(V*=V,o=V*V*F.dot3(I,O,T));var H=.6-A*A-N*N-R*R;return H<0?r=0:(H*=H,r=H*H*C.dot3(A,N,R)),32*(a+i+o+r)}perlin2(e,t){var n=Math.floor(e),a=Math.floor(t);e-=n,t-=a,n&=255,a&=255;var i=this._gradP[n+this._perm[a]].dot2(e,t),s=this._gradP[n+this._perm[a+1]].dot2(e,t-1),l=this._gradP[n+1+this._perm[a]].dot2(e-1,t),c=this._gradP[n+1+this._perm[a+1]].dot2(e-1,t-1),u=o(e);return r(r(i,l,u),r(s,c,u),o(t))}perlin3(e,t,n){var a=Math.floor(e),i=Math.floor(t),s=Math.floor(n);e-=a,t-=i,n-=s,a&=255,i&=255,s&=255;var l=this._gradP[a+this._perm[i+this._perm[s]]].dot3(e,t,n),c=this._gradP[a+this._perm[i+this._perm[s+1]]].dot3(e,t,n-1),u=this._gradP[a+this._perm[i+1+this._perm[s]]].dot3(e,t-1,n),d=this._gradP[a+this._perm[i+1+this._perm[s+1]]].dot3(e,t-1,n-1),h=this._gradP[a+1+this._perm[i+this._perm[s]]].dot3(e-1,t,n),p=this._gradP[a+1+this._perm[i+this._perm[s+1]]].dot3(e-1,t,n-1),f=this._gradP[a+1+this._perm[i+1+this._perm[s]]].dot3(e-1,t-1,n),m=this._gradP[a+1+this._perm[i+1+this._perm[s+1]]].dot3(e-1,t-1,n-1),v=o(e),g=o(t),_=o(n);return r(r(r(l,h,v),r(c,p,v),_),r(r(u,f,v),r(d,m,v),_),g)}},f=n("2aaf"),m=n.n(f),v=class{constructor(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.random();this._noiseGenes=[],this._seed=Math.trunc(4294967295*t),this.octaves=e}set octaves(e){if(e=Math.trunc(e),this._noiseGenes.length!==e){this._noiseGenes.length=e;for(var t=new m.a(this._seed),n=0;n<e;++n){var a=t.random(),i=this._noiseGenes[n];i?i.seed=a:i=this._noiseGenes[n]=new p(a)}}}get octaves(){return this._noiseGenes.length}noise(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=0,s=n,l=o,c=0;c<this._noiseGenes.length;c++){var u=this._noiseGenes[c].perlin2(e*s,t*s);r+=u*l,l*=a,s*=i}return r}};function g(e,t,n,a,i,o,r){if(!(n<=0)){n>e.length&&(n=e.length);for(var s=0;s<n;++s){var l=P(s+t,e.length),c={r:o(s,a.r,i.r-a.r,n),g:o(s,a.g,i.g-a.g,n),b:o(s,a.b,i.b-a.b,n),a:o(s,a.a,i.a-a.a,n)},u=r(s/n,c),d=Math.round(u.r),h=Math.round(u.g),p=Math.round(u.b),f=Math.round(255*u.a);e[l]=d|h<<8|p<<16|f<<24}return t+n}}function w(e,t,n){var a=[...n];a.sort((e,t)=>e.pos-t.pos);for(var i=0;i<a.length;++i){var o=(i+1)%a.length,r=a[i],s=a[o],l=r.pos*t,c=s.pos*t,u=Math.round(l),d=Math.round(c),h=d-u;if(o<=i&&(h=t-u+d),h<=0)e[u]=r.color;else{var p=(e,t)=>t;r.isNoisy&&r.noise&&(p=b(r.noise)),g(e,u,h,r.color,s.color,r.easeFun,p)}}}function b(e){var t=new v(e.octaves,e.seed);return function(n,a){var i=0,o=t.noise(n,i,e.frequency,e.gain,e.lacunarity,e.amplitude);return N(a,o)}}function y(e,t,n){if(e.length!=t.length)return console.assert(!1,"Palette arguments must have same size"),null;for(var a=_.cloneDeep(t),i=0;i<e.length;++i)a[i].color=E(e[i].color,t[i].color,n);return a}function E(e,t,n){return{r:Math.round(e.r+(t.r-e.r)*n),g:Math.round(e.g+(t.g-e.g)*n),b:Math.round(e.b+(t.b-e.b)*n),a:Math.round(e.a+(t.a-e.a)*n)}}function x(e){var t=a(e).toRgb(),n=222.4922359499622;return e.h=(e.h+n)%360,t}function P(e,t){return e-t*Math.floor(e/t)}function S(e,t,n){return e<t?t:e>n?n:e}function I(e,t,n){return e+(t-e)*n}function O(e,t,n,a,i){return I(I(e,t,n),a,i)}function T(e){return(Math.max(e.r,e.g,e.b)+Math.min(e.r,e.g,e.b))/255/2}function A(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:T(e);if(n=2*n-1,n<0){if(-1===n)return t*=255,{r:t,g:t,b:t,a:e.a};t=2*t-1;var a=-n,i=-Math.min(t,0),o=(i-a)/(1-a),r=Math.max(t,0);return{r:O(e.r,0,o,255,r),g:O(e.g,0,o,255,r),b:O(e.b,0,o,255,r),a:e.a}}if(1===n)return t*=255,{r:t,g:t,b:t,a:e.a};t=2*t-1;var s=n,l=Math.max(t,0),c=(l-s)/(1-s),u=-Math.min(t,0);return{r:O(e.r,255,c,0,u),g:O(e.g,255,c,0,u),b:O(e.b,255,c,0,u),a:e.a}}function N(e,t){var n=T(e),a=S(n+t,0,1);return A(e,a,n)}n.d(t,"e",(function(){return w})),n.d(t,"a",(function(){return y})),n.d(t,"d",(function(){return x})),n.d(t,"c",(function(){return P})),n.d(t,"b",(function(){return S}))},ca11:function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return i}));n("25f0");class a{constructor(e,t){Object.defineProperty(this,"$attrs",{enumerable:!1,configurable:!1,writable:!0,value:e}),Object.assign(this,t)}}class i extends a{constructor(e){super(e)}$serialize(e){return e.toString()}$deserialize(e){return e}$displayValue(e){return e.toString()}$parseError(e){console.error("Invalid option value:",e,", descriptor:",this)}get $defaultComponent(){return null}get $component(){return this.$attrs.component||this.$defaultComponent}}},dcbd:function(e,t,n){"use strict";n.r(t),n.d(t,"linear",(function(){return a})),n.d(t,"inQuad",(function(){return i})),n.d(t,"outQuad",(function(){return o})),n.d(t,"inOutQuad",(function(){return r})),n.d(t,"inCubic",(function(){return s})),n.d(t,"outCubic",(function(){return l})),n.d(t,"inOutCubic",(function(){return c})),n.d(t,"inQuart",(function(){return u})),n.d(t,"outQuart",(function(){return d})),n.d(t,"inOutQuart",(function(){return h})),n.d(t,"inQuint",(function(){return p})),n.d(t,"outQuint",(function(){return f})),n.d(t,"inOutQuint",(function(){return m})),n.d(t,"inSine",(function(){return v})),n.d(t,"outSine",(function(){return g})),n.d(t,"inOutSine",(function(){return _})),n.d(t,"inOutSine2_3",(function(){return w})),n.d(t,"inOutSine2_5",(function(){return b})),n.d(t,"inOutSine2_9",(function(){return y})),n.d(t,"inOutSine2_13",(function(){return E})),n.d(t,"inExpo",(function(){return x})),n.d(t,"outExpo",(function(){return P})),n.d(t,"inOutExpo",(function(){return S})),n.d(t,"inExpo2",(function(){return I})),n.d(t,"outExpo2",(function(){return O})),n.d(t,"inOutExpo2",(function(){return T})),n.d(t,"inCirc",(function(){return A})),n.d(t,"outCirc",(function(){return N})),n.d(t,"inOutCirc",(function(){return R})),n.d(t,"inElastic",(function(){return z})),n.d(t,"outElastic",(function(){return D})),n.d(t,"inOutElastic",(function(){return F})),n.d(t,"inBack",(function(){return C})),n.d(t,"outBack",(function(){return M})),n.d(t,"inOutBack",(function(){return L})),n.d(t,"inBounce",(function(){return V})),n.d(t,"outBounce",(function(){return H})),n.d(t,"inOutBounce",(function(){return U}));var a=(e,t,n,a)=>n*e/a+t,i=(e,t,n,a)=>n*(e/=a)*e+t,o=(e,t,n,a)=>-n*(e/=a)*(e-2)+t,r=(e,t,n,a)=>{return(e/=a/2)<1?n/2*e*e+t:-n/2*(--e*(e-2)-1)+t},s=(e,t,n,a)=>n*(e/=a)*e*e+t,l=(e,t,n,a)=>n*((e=e/a-1)*e*e+1)+t,c=(e,t,n,a)=>{return(e/=a/2)<1?n/2*e*e*e+t:n/2*((e-=2)*e*e+2)+t},u=(e,t,n,a)=>n*(e/=a)*e*e*e+t,d=(e,t,n,a)=>-n*((e=e/a-1)*e*e*e-1)+t,h=(e,t,n,a)=>{return(e/=a/2)<1?n/2*e*e*e*e+t:-n/2*((e-=2)*e*e*e-2)+t},p=(e,t,n,a)=>n*(e/=a)*e*e*e*e+t,f=(e,t,n,a)=>n*((e=e/a-1)*e*e*e*e+1)+t,m=(e,t,n,a)=>{return(e/=a/2)<1?n/2*e*e*e*e*e+t:n/2*((e-=2)*e*e*e*e+2)+t},v=(e,t,n,a)=>-n*Math.cos(e/a*(Math.PI/2))+n+t,g=(e,t,n,a)=>n*Math.sin(e/a*(Math.PI/2))+t,_=(e,t,n,a)=>-n/2*(Math.cos(Math.PI*e/a)-1)+t,w=(e,t,n,a)=>-n/2*(.6*Math.cos(Math.PI*e/a)+.4*Math.cos(Math.PI*e/a*3)-1)+t,b=(e,t,n,a)=>-n/2*(.875*Math.cos(Math.PI*e/a)+.125*Math.cos(Math.PI*e/a*5)-1)+t,y=(e,t,n,a)=>-n/2*(.875*Math.cos(Math.PI*e/a)+.125*Math.cos(Math.PI*e/a*9)-1)+t,E=(e,t,n,a)=>-n/2*(.9*Math.cos(Math.PI*e/a)+.1*Math.cos(Math.PI*e/a*13)-1)+t,x=(e,t,n,a)=>0==e?t:n*Math.pow(2,10*(e/a-1))+t,P=(e,t,n,a)=>e==a?t+n:n*(1-Math.pow(2,-10*e/a))+t,S=(e,t,n,a)=>{return 0==e?t:e==a?t+n:(e/=a/2)<1?n/2*Math.pow(2,10*(e-1))+t:n/2*(2-Math.pow(2,-10*--e))+t},I=(e,t,n,a)=>0==e?t:n*Math.pow(2,20*(e/a-1))+t,O=(e,t,n,a)=>e==a?t+n:n*(1-Math.pow(2,-20*e/a))+t,T=(e,t,n,a)=>{return 0==e?t:e==a?t+n:(e/=a/2)<1?n/2*Math.pow(2,20*(e-1))+t:n/2*(2-Math.pow(2,-20*--e))+t},A=(e,t,n,a)=>-n*(Math.sqrt(1-(e/=a)*e)-1)+t,N=(e,t,n,a)=>n*Math.sqrt(1-(e=e/a-1)*e)+t,R=(e,t,n,a)=>{return(e/=a/2)<1?-n/2*(Math.sqrt(1-e*e)-1)+t:n/2*(Math.sqrt(1-(e-=2)*e)+1)+t},z=(e,t,n,a)=>{var i=1.70158,o=0,r=n;return 0==e?t:1==(e/=a)?t+n:(o||(o=.3*a),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),-r*Math.pow(2,10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)+t)},D=(e,t,n,a)=>{var i=1.70158,o=0,r=n;return 0==e?t:1==(e/=a)?t+n:(o||(o=.3*a),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),r*Math.pow(2,-10*e)*Math.sin((e*a-i)*(2*Math.PI)/o)+n+t)},F=(e,t,n,a)=>{var i=1.70158,o=0,r=n;return 0==e?t:2==(e/=a/2)?t+n:(o||(o=a*(.3*1.5)),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),e<1?r*Math.pow(2,10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)*-.5+t:r*Math.pow(2,-10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)*.5+n+t)},C=(e,t,n,a,i)=>{return void 0==i&&(i=1.70158),n*(e/=a)*e*((i+1)*e-i)+t},M=(e,t,n,a,i)=>{return void 0==i&&(i=1.70158),n*((e=e/a-1)*e*((i+1)*e+i)+1)+t},L=(e,t,n,a,i)=>{return void 0==i&&(i=1.70158),(e/=a/2)<1?n/2*(e*e*((1+(i*=1.525))*e-i))+t:n/2*((e-=2)*e*((1+(i*=1.525))*e+i)+2)+t},V=(e,t,n,a)=>n-H(a-e,0,n,a)+t,H=(e,t,n,a)=>{return(e/=a)<1/2.75?n*(7.5625*e*e)+t:e<2/2.75?n*(7.5625*(e-=1.5/2.75)*e+.75)+t:e<2.5/2.75?n*(7.5625*(e-=2.25/2.75)*e+.9375)+t:n*(7.5625*(e-=2.625/2.75)*e+.984375)+t},U=(e,t,n,a)=>{return e<a/2?.5*V(2*e,0,n,a)+t:.5*H(2*e-a,0,n,a)+.5*n+t}},fc79:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-tabs",{attrs:{value:e.tabIndex},on:{input:function(t){return e.$emit("update:tabIndex",t)}}},e._l(e.optView.groups,(function(t,a){return n("b-tab",{key:e.childId(a),attrs:{id:e.childId(a),title:t.title}},[n(e.contentComponentName(t),{tag:"component",staticClass:"container px-0",attrs:{id:e.childId(a),optData:e.optData,optDesc:e.optDesc,optView:t},on:{"opt-modified":function(t){return e.$emit("opt-modified",t)}}})],1)})),1)},i=[],o=n("ca11"),r=n("4752"),s={name:"z42opt-tabs",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0},tabIndex:{type:Number,required:!1,default:0}},methods:{childId(e){return r["c"](this.id,e,"#")},contentComponentName(e){return e.component?e.component:e.groups?"z42opt-tabs":"z42opt-container"}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports}});
//# sourceMappingURL=app.d8e2a57a.js.map